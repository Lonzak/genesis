package com.projetloki.genesis.image;

import java.io.Serializable;

import com.google.common.hash.PrimitiveSink;

/**
 * A {@link Shape} factory to construct shapes fitting the size of an image.
 *
 * <p>Shapers are immutable. All the methods transforming a shaper, e.g.
 * {@link #flipX()}, return a new shaper which is the result of the
 * transformation and leave the original shaper unmodified.</p>
 *
 * <p>All methods return serializable shapers as long as {@code this} and the
 * arguments are serializable.</p>
 *
 * @see Shapers
 * @see Image#mask(Shaper)
 * @author Cl√©ment Roux
 */
public abstract class Shaper implements Hashable {
  /**
   * Returns a shape fitting an image with the given size.
   * @param width the width of the image
   * @param height the height of the image
   */
  public abstract Shape getShape(int width, int height);

  /**
   * Returns a factory which generates a shape by extracting the complement of
   * the shape generated by {@code this}.
   * @return the complement of {@code this} shaper
   * @see Shape#negate()
   */
  public Shaper negate() {
    return new NegateShaper(this);
  }

  /**
   * Returns a factory which generates a shape by flipping horizontally the
   * shape generated by {@code this}.
   * @return an horizontally-flipped copy of {@code this} shaper
   */
  public Shaper flipX() {
    return new FlipXShaper(this);
  }

  /**
   * Returns a factory which generates a shape by flipping vertically the shape
   * generated by {@code this}.
   * @return a vertically-flipped copy of {@code this} shaper
   */
  public Shaper flipY() {
    return new FlipYShaper(this);
  }

  /**
   * Returns a factory which, given a rectangle, generates a shape fitting the
   * rectangle minus the given borders using {@code this}.
   * @param topPadding the width of the top border. Can be negative.
   * @param rightPadding the width of the right border. Can be negative.
   * @param bottomPadding the width of the bottom border. Can be negative.
   * @param leftPadding the width of the left border. Can be negative.
   * @return a padded copy of this shaper
   */
  public Shaper pad(int topPadding, int rightPadding, int bottomPadding,
      int leftPadding) {
    return new PadShaper(this, topPadding, rightPadding, bottomPadding,
        leftPadding);
  }

  /**
   * Returns a shaper generating a shape by rotating counterclockwise the shape
   * generated by {@code this}.
   * @return a counterclockwise-rotated copy of {@code this} shaper
   */
  public Shaper rotateCcw() {
    return new RotateCcwShaper(this);
  }

  /**
   * Returns a shaper generating a shape by rotating clockwise the shape
   * generated by {@code this}.
   * @return a clockwise-rotated copy of {@code this} shaper
   */
  public Shaper rotateCw() {
    return new RotateCwShaper(this);
  }

  @Override public final int hashCode() {
    return hash().hashCode();
  }

  // ---------------------------------------------------------------------------
  // Implementations
  // ---------------------------------------------------------------------------

  private static class NegateShaper extends HashCachingShaper<NegateShaper>
      implements Serializable {
    final Shaper operand;

    NegateShaper(Shaper operand) {
      this.operand = operand;
    }

    @Override public Shape getShape(int width, int height) {
      return operand.getShape(width, height).negate();
    }

    @Override void doHash(PrimitiveSink sink) {
      sink.putLong(17140574680447414L)
          .putBytes(operand.hash().asBytes());
    }

    @Override public boolean doEquals(NegateShaper that) {
      return operand.equals(that.operand);
    }

    @Override public String toString() {
      return operand + ".negate()";
    }

    private static final long serialVersionUID = 0;
  }

  private static class FlipXShaper extends HashCachingShaper<FlipXShaper>
      implements Serializable {
    final Shaper operand;

    FlipXShaper(Shaper operand) {
      this.operand = operand;
    }

    @Override public Shape getShape(int width, int height) {
      return operand.getShape(width, height).flipX(width / 2d);
    }

    @Override void doHash(PrimitiveSink sink) {
      sink.putLong(7997867266875384454L)
          .putBytes(operand.hash().asBytes());
    }

    @Override public boolean doEquals(FlipXShaper that) {
      return operand.equals(that.operand);
    }

    @Override public String toString() {
      return operand + ".flipX()";
    }

    private static final long serialVersionUID = 0;
  }

  private static class FlipYShaper extends HashCachingShaper<FlipYShaper>
      implements Serializable {
    final Shaper operand;

    FlipYShaper(Shaper operand) {
      this.operand = operand;
    }

    @Override public Shape getShape(int width, int height) {
      return operand.getShape(width, height).flipY(height / 2d);
    }

    @Override void doHash(PrimitiveSink sink) {
      sink.putLong(-1403330385717108244L)
          .putBytes(operand.hash().asBytes());
    }

    @Override public boolean doEquals(FlipYShaper that) {
      return operand.equals(that.operand);
    }

    @Override public String toString() {
      return operand + ".flipY()";
    }

    private static final long serialVersionUID = 0;
  }

  private static class PadShaper extends HashCachingShaper<PadShaper>
      implements Serializable {
    final Shaper operand;
    final int topPadding;
    final int rightPadding;
    final int bottomPadding;
    final int leftPadding;

    PadShaper(Shaper operand, int topPadding, int rightPadding,
        int bottomPadding, int leftPadding) {
      this.operand = operand;
      this.topPadding = topPadding;
      this.rightPadding = rightPadding;
      this.bottomPadding = bottomPadding;
      this.leftPadding = leftPadding;
    }

    @Override public Shape getShape(int width, int height) {
      width -= (rightPadding + leftPadding);
      height -= (topPadding + bottomPadding);
      return operand.getShape(width, height).translate(leftPadding, topPadding);
    }

    @Override void doHash(PrimitiveSink sink) {
      sink.putLong(-5924112503117664739L)
          .putBytes(operand.hash().asBytes())
          .putInt(topPadding)
          .putInt(rightPadding)
          .putInt(bottomPadding)
          .putInt(leftPadding);
    }

    @Override public boolean doEquals(PadShaper that) {
      return operand.equals(that.operand) && topPadding == that.topPadding &&
          rightPadding == that.rightPadding &&
          bottomPadding == that.bottomPadding &&
          leftPadding == that.leftPadding;
    }

    @Override public String toString() {
      return String.format("%s.pad(%s, %s, %s, %s)",
          operand, topPadding, rightPadding, bottomPadding, leftPadding);
    }

    private static final long serialVersionUID = 0;
  }

  private static class RotateCcwShaper
      extends HashCachingShaper<RotateCcwShaper> implements Serializable {
    final Shaper operand;

    RotateCcwShaper(Shaper operand) {
      this.operand = operand;
    }

    @Override public Shape getShape(int width, int height) {
      return operand.getShape(height, width).rotateCcw(width);
    }

    @Override void doHash(PrimitiveSink sink) {
      sink.putLong(182969130853322754L)
          .putBytes(operand.hash().asBytes());
    }

    @Override public boolean doEquals(RotateCcwShaper that) {
      return operand.equals(that.operand);
    }

    @Override public String toString() {
      return operand + ".rotateCcw()";
    }

    private static final long serialVersionUID = 0;
  }

  private static class RotateCwShaper extends HashCachingShaper<RotateCwShaper>
      implements Serializable {
    final Shaper operand;

    RotateCwShaper(Shaper operand) {
      this.operand = operand;
    }

    @Override public Shape getShape(int width, int height) {
      return operand.getShape(height, width).rotateCw(height);
    }

    @Override void doHash(PrimitiveSink sink) {
      sink.putLong(-8668860812137950439L)
          .putBytes(operand.hash().asBytes());
    }

    @Override public boolean doEquals(RotateCwShaper that) {
      return operand.equals(that.operand);
    }

    @Override public String toString() {
      return operand + ".rotateCw()";
    }

    private static final long serialVersionUID = 0;
  }
}
